{% extends 'base.html' %}

{% block title %}Admin Dashboard - Squishy{% endblock %}

{% block content %}
<div class="admin-dashboard">
    <h1>Admin Dashboard</h1>

    <div class="admin-section">
        <h2>Media Source Configuration</h2>
        <div class="card">
            <form action="{{ url_for('admin.update_source') }}" method="post" id="sourceForm">
                <div class="form-group">
                    <label>Select Media Source:</label>
                    <div class="radio-group">
                        <label><input type="radio" name="source" value="jellyfin" {% if config.jellyfin_url or not config.plex_url %}checked{% endif %} required onclick="toggleSourceFields()"> Jellyfin</label>
                        <label><input type="radio" name="source" value="plex" {% if config.plex_url %}checked{% endif %} onclick="toggleSourceFields()"> Plex</label>
                    </div>
                    <p class="help-text">Squishy requires either a Jellyfin or Plex connection to function.</p>
                </div>

                <div id="jellyfinFields" class="source-fields" {% if not config.jellyfin_url %}style="display:none"{% endif %}>
                    <div class="form-group">
                        <label for="jellyfin_url">Jellyfin URL</label>
                        <input type="text" id="jellyfin_url" name="jellyfin_url" value="{{ config.jellyfin_url or '' }}" placeholder="http://jellyfin:8096">
                    </div>
                    <div class="form-group">
                        <label for="jellyfin_api_key">Jellyfin API Key</label>
                        <input type="text" id="jellyfin_api_key" name="jellyfin_api_key" value="{{ config.jellyfin_api_key or '' }}" placeholder="your_api_key">
                    </div>
                </div>

                <div id="plexFields" class="source-fields" {% if not config.plex_url %}style="display:none"{% endif %}>
                    <div class="form-group">
                        <label for="plex_url">Plex URL</label>
                        <input type="text" id="plex_url" name="plex_url" value="{{ config.plex_url or '' }}" placeholder="http://plex:32400">
                    </div>
                    <div class="form-group">
                        <label for="plex_token">Plex Token</label>
                        <input type="text" id="plex_token" name="plex_token" value="{{ config.plex_token or '' }}" placeholder="your_plex_token">
                    </div>
                </div>

                <div class="form-submit">
                    <button type="submit">Save Configuration</button>
                </div>
            </form>
        </div>
    </div>

    <div class="admin-section">
        <h2>Scan Media Library</h2>
        <div class="card">
            <form action="{{ url_for('admin.scan') }}" method="post">
                <input type="hidden" id="scan_type" name="scan_type" value="{% if config.jellyfin_url %}jellyfin{% else %}plex{% endif %}">
                <p>Scan your media from the configured source to update the library.</p>
                <div class="form-submit">
                    <button type="submit" id="scanButton">Start Scan</button>
                </div>
            </form>
        </div>
    </div>

    <div class="admin-section" id="path-config">
        <h2>Path Configuration</h2>
        <div class="card">
            <form action="{{ url_for('admin.update_paths_and_mapping') }}" method="post">
                <div class="form-group">
                    <label for="media_path">Media Path</label>
                    <p class="help-text">The directory where your media files are stored.</p>
                    <div class="input-with-button">
                        <input type="text" id="media_path" name="media_path" value="{{ config.media_path }}" class="full-width">
                        <button type="button" class="browse-button" onclick="openFileBrowser('media_path')">Browse</button>
                    </div>
                </div>

                <div class="form-group">
                    <label for="transcode_path">Squished Output Path</label>
                    <p class="help-text">Directory where squished files will be stored.</p>
                    <div class="input-with-button">
                        <input type="text" id="transcode_path" name="transcode_path" value="{{ config.transcode_path }}" class="full-width">
                        <button type="button" class="browse-button" onclick="openFileBrowser('transcode_path')">Browse</button>
                    </div>
                </div>

                <div class="form-group">
                    <label for="ffmpeg_path">FFmpeg Path</label>
                    <p class="help-text">Path to the FFmpeg executable. This is required for transcoding.</p>
                    <div class="input-with-button">
                        <input type="text" id="ffmpeg_path" name="ffmpeg_path" value="{{ config.ffmpeg_path }}" class="full-width">
                        <button type="button" class="browse-button" onclick="openFileBrowser('ffmpeg_path')">Browse</button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="max_concurrent_jobs">Max Concurrent Jobs</label>
                    <input type="number" id="max_concurrent_jobs" name="max_concurrent_jobs" value="{{ config.max_concurrent_jobs }}" min="1" max="10">
                    <p class="help-text">Maximum number of transcoding jobs that can run simultaneously. Additional jobs will be queued.</p>
                </div>

                <hr>
                <h3>Path Mapping</h3>
                <p class="help-text">Path mapping helps resolve path differences between media servers and Squishy. For example, if your media server reports paths as "/media/Movies" but Squishy accesses them at "/opt/Media/Movies", you would map "/media" to "/opt/Media".</p>

                <div class="path-mapping-row">
                    <div class="form-group">
                        <label for="source_path">Media Server Path</label>
                        <input type="text" id="source_path" name="source_path" value="{% if config.path_mappings and config.path_mappings.keys()|list %}{{ config.path_mappings.keys()|list|first }}{% else %}{% endif %}" placeholder="/media">
                    </div>
                    <div class="form-group">
                        <label for="target_path">Squishy Path</label>
                        <input type="text" id="target_path" name="target_path" value="{% if config.path_mappings and config.path_mappings.values()|list %}{{ config.path_mappings.values()|list|first }}{% else %}{% endif %}" placeholder="/opt/media">
                    </div>
                </div>

                <div class="form-submit">
                    <button type="submit" class="button">Save Configuration</button>
                </div>
            </form>
        </div>
    </div>

<!-- File Browser Modal -->
<div id="fileBrowserModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="fileBrowserTitle">Browse Directories</h2>
            <span class="close" onclick="closeFileBrowser()">&times;</span>
        </div>
        <div class="modal-body">
            <div class="current-path">
                <span id="currentPath">/</span>
            </div>
            <div class="directory-list" id="directoryList">
                <!-- Directory content will be loaded here -->
            </div>
        </div>
        <div class="modal-footer">
            <button type="button" onclick="selectCurrentPath()">Select Current Path</button>
            <button type="button" onclick="closeFileBrowser()">Cancel</button>
        </div>
    </div>
</div>

<form id="scanForm" action="{{ url_for('admin.scan') }}" method="post" style="display:none">
    <input type="hidden" id="scan_type" name="scan_type" value="{% if config.jellyfin_url %}jellyfin{% else %}plex{% endif %}">
</form>

<script>
    function toggleSourceFields() {
        // Hide all source fields first
        document.querySelectorAll('.source-fields').forEach(function(el) {
            el.style.display = 'none';
        });

        // Show the selected source fields
        var selectedSource = document.querySelector('input[name="source"]:checked').value;
        document.getElementById(selectedSource + 'Fields').style.display = 'block';

        // Update the scan type in the hidden form
        document.getElementById('scan_type').value = selectedSource;
    }
    
    function toggleHwDeviceField() {
        const hwAccelSelect = document.getElementById('hw_accel');
        const hwDeviceGroup = document.getElementById('hw_device_group');
        
        // Show device field only for methods that need it
        if (hwAccelSelect.value === 'nvenc' || hwAccelSelect.value === 'cuda' || hwAccelSelect.value === 'vaapi') {
            hwDeviceGroup.style.display = 'block';
        } else {
            hwDeviceGroup.style.display = 'none';
        }
    }

    function scanMedia() {
        var selectedSource = document.querySelector('input[name="source"]:checked').value;

        // Check if necessary credentials are provided for media servers
        if (selectedSource === 'jellyfin') {
            var jellyfinUrl = document.getElementById('jellyfin_url').value;
            var jellyfinApiKey = document.getElementById('jellyfin_api_key').value;
            if (!jellyfinUrl || !jellyfinApiKey) {
                alert('Please provide Jellyfin URL and API Key before scanning.');
                return;
            }
        } else if (selectedSource === 'plex') {
            var plexUrl = document.getElementById('plex_url').value;
            var plexToken = document.getElementById('plex_token').value;
            if (!plexUrl || !plexToken) {
                alert('Please provide Plex URL and Token before scanning.');
                return;
            }
        }

        // Submit the scan form
        document.getElementById('scanForm').submit();
    }

    // File browser functionality
    let currentTargetField = null;
    let currentPath = '/';
    let currentFileType = 'directory';

    function openFileBrowser(targetFieldId) {
        currentTargetField = targetFieldId;
        currentPath = '/';
        document.getElementById('currentPath').textContent = currentPath;
        
        // Set file type based on the target field
        currentFileType = targetFieldId === 'ffmpeg_path' ? 'file' : 'directory';
        
        // Update modal title based on what we're browsing for
        const modalTitle = document.getElementById('fileBrowserTitle');
        if (modalTitle) {
            if (currentFileType === 'file') {
                modalTitle.textContent = 'Select FFmpeg Executable';
            } else {
                modalTitle.textContent = 'Browse Directories';
            }
        }

        // Load the root directory
        loadDirectoryContents(currentPath);

        // Show the modal
        document.getElementById('fileBrowserModal').style.display = 'block';
    }

    function closeFileBrowser() {
        document.getElementById('fileBrowserModal').style.display = 'none';
    }

    function loadDirectoryContents(path) {
        // Make an AJAX request to get directory contents
        fetch(`{{ url_for('admin.browse_filesystem') }}?path=${encodeURIComponent(path)}&type=${currentFileType}`)
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert(`Error: ${data.error}`);
                    return;
                }

                const directoryList = document.getElementById('directoryList');
                directoryList.innerHTML = '';

                // Add parent directory option if not at root
                if (path !== '/') {
                    const parentItem = document.createElement('div');
                    parentItem.className = 'directory-item parent';
                    parentItem.innerHTML = '<span class="directory-icon">📁</span> ..';
                    parentItem.addEventListener('click', () => {
                        const parentPath = path.split('/').slice(0, -1).join('/') || '/';
                        navigateToDirectory(parentPath);
                    });
                    directoryList.appendChild(parentItem);
                }

                // Add directories
                data.directories.forEach(dir => {
                    const dirItem = document.createElement('div');
                    dirItem.className = 'directory-item';
                    dirItem.innerHTML = `<span class="directory-icon">📁</span> ${dir}`;
                    dirItem.addEventListener('click', () => {
                        const newPath = path === '/' ? `/${dir}` : `${path}/${dir}`;
                        navigateToDirectory(newPath);
                    });
                    directoryList.appendChild(dirItem);
                });
                
                // Add files (only for ffmpeg selection)
                if (data.files && currentFileType === 'file') {
                    data.files.forEach(file => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'directory-item file-item';
                        fileItem.innerHTML = `<span class="file-icon">⚙️</span> ${file}`;
                        fileItem.addEventListener('click', () => {
                            selectFile(path, file);
                        });
                        directoryList.appendChild(fileItem);
                    });
                }
            })
            .catch(error => {
                console.error('Error fetching directory contents:', error);
                alert('Failed to load directory contents. See console for details.');
            });
    }

    function navigateToDirectory(path) {
        currentPath = path;
        document.getElementById('currentPath').textContent = currentPath;
        loadDirectoryContents(path);
    }
    
    function selectFile(path, filename) {
        const fullPath = path === '/' ? `/${filename}` : `${path}/${filename}`;
        const targetField = document.getElementById(currentTargetField);
        targetField.value = fullPath;
        closeFileBrowser();
    }

    function selectCurrentPath() {
        const targetField = document.getElementById(currentTargetField);
        // Only select the current path if we're browsing for directories
        if (currentFileType === 'directory') {
            targetField.value = currentPath;
            closeFileBrowser();
        } else {
            // For files, show a message that they need to select a file
            alert('Please select an FFmpeg executable file.');
        }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        toggleSourceFields();
        
        // Set up hardware acceleration UI interactions
        const hwAccelSelect = document.getElementById('hw_accel');
        if (hwAccelSelect) {
            hwAccelSelect.addEventListener('change', toggleHwDeviceField);
        }
        
        // Set up hardware acceleration detection
        const detectHwAccelButton = document.querySelector('a[href="{{ url_for("admin.detect_hw_accel_route") }}"]');
        if (detectHwAccelButton) {
            detectHwAccelButton.addEventListener('click', function(e) {
                e.preventDefault();
                detectHardwareAcceleration();
            });
        }
    });
    
    function detectHardwareAcceleration() {
        // Show loading message
        const hwaccelResults = document.getElementById('hwaccel-results');
        const methodsDiv = document.getElementById('hwaccel-methods');
        const devicesDiv = document.getElementById('hwaccel-devices');
        
        methodsDiv.innerHTML = '<p>Detecting hardware acceleration methods. This may take a few moments...</p>';
        hwaccelResults.style.display = 'block';
        
        // Make API request to detect hardware acceleration
        fetch('{{ url_for("admin.detect_hw_accel_route") }}')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                // Display results
                displayHardwareAccelerationResults(data);
            })
            .catch(error => {
                methodsDiv.innerHTML = `<p class="error">Error detecting hardware acceleration: ${error.message}</p>`;
            });
    }
    
    function displayHardwareAccelerationResults(data) {
        const methodsDiv = document.getElementById('hwaccel-methods');
        const devicesDiv = document.getElementById('hwaccel-devices');
        const hwAccelSelect = document.getElementById('hw_accel');
        const hwDeviceInput = document.getElementById('hw_device');
        
        // Clear previous results
        methodsDiv.innerHTML = '';
        devicesDiv.innerHTML = '';
        
        // Methods
        if (data.methods && data.methods.length > 0) {
            const methodsList = document.createElement('ul');
            data.methods.forEach(method => {
                const li = document.createElement('li');
                
                // Create method entry with apply button
                const methodSpan = document.createElement('span');
                methodSpan.textContent = method;
                li.appendChild(methodSpan);
                
                // Only add apply button for usable HW acceleration methods
                if (['nvenc', 'cuda', 'qsv', 'vaapi', 'videotoolbox', 'amf'].includes(method)) {
                    const applyButton = document.createElement('button');
                    applyButton.textContent = 'Use';
                    applyButton.className = 'button small';
                    applyButton.style.marginLeft = '10px';
                    applyButton.addEventListener('click', function() {
                        // Set the hardware acceleration method
                        hwAccelSelect.value = method;
                        
                        // Trigger change event to update device field visibility
                        const event = new Event('change');
                        hwAccelSelect.dispatchEvent(event);
                    });
                    li.appendChild(applyButton);
                }
                
                methodsList.appendChild(li);
            });
            methodsDiv.appendChild(methodsList);
        } else {
            methodsDiv.innerHTML = '<p>No hardware acceleration methods detected.</p>';
        }
        
        // Devices
        let hasDevices = false;
        
        if (data.devices) {
            for (const [type, devices] of Object.entries(data.devices)) {
                if (devices.length > 0) {
                    hasDevices = true;
                    
                    const deviceHeader = document.createElement('h4');
                    deviceHeader.textContent = type.toUpperCase();
                    devicesDiv.appendChild(deviceHeader);
                    
                    const devicesList = document.createElement('ul');
                    devices.forEach(device => {
                        const li = document.createElement('li');
                        
                        // Display device info with apply button
                        let deviceText = '';
                        let deviceValue = '';
                        
                        if (device.name && device.index) {
                            deviceText = `${device.name} (${device.index})`;
                            deviceValue = device.index;
                        } else if (device.path) {
                            deviceText = device.path;
                            deviceValue = device.path;
                        } else {
                            deviceText = JSON.stringify(device);
                        }
                        
                        const deviceSpan = document.createElement('span');
                        deviceSpan.textContent = deviceText;
                        li.appendChild(deviceSpan);
                        
                        // Add apply button for devices that match the acceleration type
                        if ((type === 'cuda' && hwAccelSelect.value === 'nvenc') || 
                            (type === hwAccelSelect.value)) {
                            const applyButton = document.createElement('button');
                            applyButton.textContent = 'Use';
                            applyButton.className = 'button small';
                            applyButton.style.marginLeft = '10px';
                            applyButton.addEventListener('click', function() {
                                // Set the device value
                                hwDeviceInput.value = deviceValue;
                            });
                            li.appendChild(applyButton);
                        }
                        
                        devicesList.appendChild(li);
                    });
                    devicesDiv.appendChild(devicesList);
                }
            }
        }
        
        if (!hasDevices) {
            devicesDiv.innerHTML = '<p>No hardware acceleration devices detected.</p>';
        }
        
        // Add Apply All button if methods were detected
        if (data.methods && data.methods.length > 0) {
            const applyContainer = document.createElement('div');
            applyContainer.style.marginTop = '20px';
            applyContainer.style.textAlign = 'right';
            
            let recommendedMethod = '';
            let recommendedDevice = '';
            
            // Determine best method to use
            if (data.methods.includes('nvenc')) {
                recommendedMethod = 'nvenc';
                if (data.devices.cuda && data.devices.cuda.length > 0) {
                    recommendedDevice = data.devices.cuda[0].index || '0';
                }
            } else if (data.methods.includes('qsv')) {
                recommendedMethod = 'qsv';
            } else if (data.methods.includes('vaapi')) {
                recommendedMethod = 'vaapi';
                if (data.devices.vaapi && data.devices.vaapi.length > 0) {
                    recommendedDevice = data.devices.vaapi[0].path;
                }
            } else if (data.methods.includes('videotoolbox')) {
                recommendedMethod = 'videotoolbox';
            } else if (data.methods.includes('amf')) {
                recommendedMethod = 'amf';
            }
            
            if (recommendedMethod) {
                const applyButton = document.createElement('button');
                applyButton.textContent = 'Apply Recommended Settings';
                applyButton.className = 'button';
                applyButton.addEventListener('click', function() {
                    // Set the hardware acceleration method
                    hwAccelSelect.value = recommendedMethod;
                    
                    // Set device if applicable
                    if (recommendedDevice) {
                        hwDeviceInput.value = recommendedDevice;
                    }
                    
                    // Trigger change event to update device field visibility
                    const event = new Event('change');
                    hwAccelSelect.dispatchEvent(event);
                });
                applyContainer.appendChild(applyButton);
                devicesDiv.appendChild(applyContainer);
            }
        }
    }
</script>
    <div class="admin-section">
        <h2>Transcoding Profiles</h2>
        <div class="card">
            <h3>Profile Management</h3>
            <p>Manage your transcoding profiles for different quality settings.</p>
            <div class="form-submit">
                <a href="{{ url_for('admin.list_profiles') }}" class="button">Manage Profiles</a>
            </div>
        </div>
    </div>
    
    <div class="admin-section">
        <h2>Hardware Acceleration</h2>
        <div class="card">
            <h3>Global Hardware Acceleration Settings</h3>
            <p class="help-text">These settings will be used by default for all transcoding profiles unless overridden in individual profiles.</p>
            
            <form action="{{ url_for('admin.update_paths_and_mapping') }}" method="post">
                <!-- Hidden fields to maintain other settings -->
                <input type="hidden" name="media_path" value="{{ config.media_path }}">
                <input type="hidden" name="transcode_path" value="{{ config.transcode_path }}">
                <input type="hidden" name="ffmpeg_path" value="{{ config.ffmpeg_path }}">
                <input type="hidden" name="max_concurrent_jobs" value="{{ config.max_concurrent_jobs }}">
                {% if config.path_mappings and config.path_mappings.keys()|list %}
                <input type="hidden" name="source_path" value="{{ config.path_mappings.keys()|list|first }}">
                {% endif %}
                {% if config.path_mappings and config.path_mappings.values()|list %}
                <input type="hidden" name="target_path" value="{{ config.path_mappings.values()|list|first }}">
                {% endif %}
                
                <div class="form-group">
                    <label for="hw_accel">Hardware Acceleration Method</label>
                    <select id="hw_accel" name="hw_accel">
                        <option value="" {% if not config.hw_accel %}selected{% endif %}>None (Software Encoding)</option>
                        <option value="nvenc" {% if config.hw_accel == "nvenc" %}selected{% endif %}>NVIDIA NVENC</option>
                        <option value="qsv" {% if config.hw_accel == "qsv" %}selected{% endif %}>Intel QuickSync (QSV)</option>
                        <option value="vaapi" {% if config.hw_accel == "vaapi" %}selected{% endif %}>VAAPI (Intel/AMD GPU)</option>
                        <option value="videotoolbox" {% if config.hw_accel == "videotoolbox" %}selected{% endif %}>VideoToolbox (macOS)</option>
                        <option value="amf" {% if config.hw_accel == "amf" %}selected{% endif %}>AMD AMF</option>
                    </select>
                </div>
                
                <div class="form-group" id="hw_device_group" {% if config.hw_accel not in ["nvenc", "cuda", "vaapi"] %}style="display:none"{% endif %}>
                    <label for="hw_device">Hardware Device</label>
                    <input type="text" id="hw_device" name="hw_device" value="{{ config.hw_device or '' }}" placeholder="e.g. /dev/dri/renderD128 or 0">
                    <p class="help-text">For CUDA/NVENC: GPU index (e.g. "0"). For VAAPI: device path (e.g. "/dev/dri/renderD128").</p>
                </div>
                
                <div class="form-submit">
                    <button type="submit" class="button">Save Hardware Settings</button>
                </div>
            </form>
            
            <hr>
            
            <h3>Hardware Detection</h3>
            <p>Detect your system's hardware acceleration capabilities to optimize transcoding performance.</p>
            <div class="form-submit">
                <a href="{{ url_for('admin.detect_hw_accel_route') }}" class="button">Detect Hardware Acceleration</a>
            </div>
            
            <div id="hwaccel-results" style="display:none; margin-top: 20px;">
                <h3>Detected Hardware Acceleration Methods</h3>
                <div id="hwaccel-methods"></div>
                
                <h3>Available Devices</h3>
                <div id="hwaccel-devices"></div>
            </div>
        </div>
    </div>
{% endblock %}
