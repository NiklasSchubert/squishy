{% extends 'base.html' %}

{% block title %}Transcoding Jobs - Squishy{% endblock %}

{% block content %}
<div class="jobs-list">
    <h1>Transcoding Jobs</h1>
    
    {% if job_data %}
    <table>
        <thead>
            <tr>
                <th>Media</th>
                <th>Size</th>
                <th>Profile</th>
                <th>Status</th>
                <th>Progress</th>
                <th>Output</th>
            </tr>
        </thead>
        <tbody>
            {% for item in job_data %}
            <tr data-job-id="{{ item.job.id }}">
                <td>{{ item.media_title }}</td>
                <td>{{ item.file_size }}</td>
                <td>{{ item.job.profile_name }}</td>
                <td class="status-{{ item.job.status }}" data-job-id="{{ item.job.id }}">
                    {{ item.job.status }}
                    {% if item.job.status == "pending" and loop.index0 > 0 %}
                    <span class="queue-position">(Queue position: {{ loop.index0 }})</span>
                    {% endif %}
                </td>
                <td>
                    {% if item.job.status == "processing" %}
                    <div class="progress-container">
                        <div class="progress-bar-row">
                            <progress value="{{ item.job.progress }}" max="1.0"></progress>
                            <span class="progress-text">{{ (item.job.progress * 100)|int }}%</span>
                        </div>
                        {% if item.job.current_time and item.job.duration %}
                        <span class="progress-time">{{ item.job.current_time|int }}s / {{ item.job.duration|int }}s</span>
                        {% endif %}
                    </div>
                    {% elif item.job.status == "completed" %}
                    <span class="status-complete">Complete</span>
                    {% elif item.job.status == "failed" %}
                    <span class="status-failed">Failed</span>
                    {% elif item.job.status == "cancelled" %}
                    <span class="status-cancelled">Cancelled</span>
                    {% else %}
                    <span class="status-pending">Pending</span>
                    {% endif %}
                </td>
                <td>
                    <div class="action-buttons-container">
                        {% if item.job.output_path %}
                        <a href="/webdav/{{ item.job.output_path.split('/')[-1] }}" target="_blank" 
                           class="circle-button download-circle-button" title="Download File">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                                <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                            </svg>
                        </a>
                        {% if item.job.output_size %}
                        <span class="output-size" title="File Size">{{ item.job.output_size }}</span>
                        {% endif %}
                        {% elif item.job.status == "processing" or item.job.status == "pending" %}
                        <form action="{{ url_for('ui.cancel_job', job_id=item.job.id) }}" method="post" class="cancel-form">
                            <button type="submit" class="circle-button cancel-button" title="Cancel Job">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                                    <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                                </svg>
                            </button>
                        </form>
                        {% endif %}
                        
                        {% if item.job.status in ["processing", "failed", "completed", "cancelled"] %}
                        <button class="circle-button logs-circle-button" data-job-id="{{ item.job.id }}" title="Show/Hide Logs">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
                                <path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/>
                            </svg>
                        </button>
                        {% endif %}
                    </div>
                </td>
            </tr>
            
            {% if item.job.status in ["processing", "failed", "completed", "cancelled"] %}
            <tr class="logs-row" id="logs-{{ item.job.id }}" style="display: none;">
                <td colspan="6">
                    <div class="logs-container">
                        <h3>FFmpeg Command:</h3>
                        <pre class="ffmpeg-command" id="command-{{ item.job.id }}">Loading...</pre>
                        <h3>FFmpeg Logs:</h3>
                        <pre class="ffmpeg-logs" id="logs-content-{{ item.job.id }}">Loading...</pre>
                        
                        {% if item.job.status == "processing" %}
                        <div class="auto-refresh-toggle">
                            <label>
                                <input type="checkbox" class="auto-refresh-logs" data-job-id="{{ item.job.id }}" checked>
                                Auto-refresh logs
                            </label>
                        </div>
                        {% endif %}
                    </div>
                </td>
            </tr>
            {% endif %}
            {% endfor %}
        </tbody>
    </table>
    {% else %}
    <div class="empty-state">
        <p>No transcoding jobs found.</p>
    </div>
    {% endif %}
</div>
{% endblock %}

{% block scripts %}
<script>
    // Instead of reloading the whole page, we'll periodically fetch job status via AJAX
    let pageReloadTimer = null;
    const openLogStates = new Set();
    const STORAGE_KEY = 'squishyOpenLogs';
    
    // Initialize the auto-refresh mechanism
    function initializeAutoRefresh() {
        if (pageReloadTimer) {
            clearTimeout(pageReloadTimer);
        }
        
        // Load saved open log states from localStorage
        try {
            const savedOpenLogs = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            savedOpenLogs.forEach(jobId => openLogStates.add(jobId));
            
            // Restore open logs from localStorage
            openLogStates.forEach(jobId => {
                const logsRow = document.getElementById(`logs-${jobId}`);
                const toggleButton = document.querySelector(`.logs-circle-button[data-job-id="${jobId}"]`);
                
                if (logsRow && toggleButton) {
                    logsRow.style.display = 'table-row';
                    toggleButton.title = 'Hide Logs';
                    
                    // Load the logs content
                    loadJobLogs(jobId);
                    
                    // Scroll to bottom after a delay to ensure content is loaded
                    setTimeout(() => {
                        const logsEl = document.getElementById(`logs-content-${jobId}`);
                        if (logsEl) scrollToBottom(logsEl);
                    }, 300);
                }
            });
        } catch (e) {
            console.error('Error loading saved log states:', e);
        }
        
        // Auto-refresh job data without reloading the page
        fetchJobUpdates();
        
        // Set up our own page reload every 30 seconds as a fallback
        // Save open log states before reloading
        pageReloadTimer = setTimeout(function() {
            saveOpenLogStates();
            location.reload();
        }, 30000);
    }
    
    // Save open log states to localStorage
    function saveOpenLogStates() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify([...openLogStates]));
        } catch (e) {
            console.error('Error saving log states:', e);
        }
    }
    
    // Fetch job updates via AJAX instead of reloading the page
    function fetchJobUpdates() {
        fetch('/api/jobs')
            .then(response => response.json())
            .then(data => {
                // Get a list of all active job IDs
                const activeJobIds = data.jobs.map(job => job.id);
                
                // Remove any open log states for jobs that no longer exist
                [...openLogStates].forEach(jobId => {
                    if (!activeJobIds.includes(jobId)) {
                        openLogStates.delete(jobId);
                        saveOpenLogStates();
                    }
                });
                
                // Update job data for each job
                data.jobs.forEach(job => {
                    updateJobElement(job);
                });
                
                // Schedule the next update
                setTimeout(fetchJobUpdates, 5000);
            })
            .catch(error => {
                console.error('Error fetching job updates:', error);
                // If there's an error, fall back to page reload
                setTimeout(function() {
                    saveOpenLogStates();
                    location.reload();
                }, 5000);
            });
    }
    
    // Update a specific job's UI elements
    function updateJobElement(job) {
        // Find the status element for this job
        const statusEl = document.querySelector(`tr td.status-${job.status}[data-job-id="${job.id}"]`);
        if (!statusEl) return;
        
        // Update the progress if it's a processing job
        const progressContainer = document.querySelector(`tr[data-job-id="${job.id}"] .progress-container`);
        if (progressContainer && job.status === 'processing') {
            const progressBar = progressContainer.querySelector('progress');
            const progressText = progressContainer.querySelector('.progress-text');
            const progressTime = progressContainer.querySelector('.progress-time');
            
            if (progressBar) progressBar.value = job.progress;
            if (progressText) progressText.textContent = `${Math.round(job.progress * 100)}%`;
            
            // If we have timing data, update it
            if (progressTime && job.current_time && job.duration) {
                progressTime.textContent = `${Math.round(job.current_time)}s / ${Math.round(job.duration)}s`;
            }
        }
        
        // If this job has logs open, refresh them
        if (openLogStates.has(job.id)) {
            loadJobLogs(job.id);
        }
    }
    
    // Toggle log visibility
    document.querySelectorAll('.logs-circle-button').forEach(button => {
        button.addEventListener('click', function() {
            const jobId = this.getAttribute('data-job-id');
            const logsRow = document.getElementById(`logs-${jobId}`);
            
            // Toggle visibility
            if (logsRow.style.display === 'none') {
                logsRow.style.display = 'table-row';
                this.title = 'Hide Logs';
                
                // Load logs and scroll to bottom on initial load
                loadJobLogs(jobId);
                
                // After logs are loaded, ensure we scroll to bottom (for the initial view)
                setTimeout(() => {
                    const logsEl = document.getElementById(`logs-content-${jobId}`);
                    scrollToBottom(logsEl);
                }, 300);
                
                openLogStates.add(jobId);
                saveOpenLogStates(); // Save the state change
            } else {
                logsRow.style.display = 'none';
                this.title = 'Show Logs';
                openLogStates.delete(jobId);
                saveOpenLogStates(); // Save the state change
            }
        });
    });
    
    // Load job logs
    function loadJobLogs(jobId) {
        const logsEl = document.getElementById(`logs-content-${jobId}`);
        const shouldAutoScroll = document.querySelector(`.auto-refresh-logs[data-job-id="${jobId}"]`)?.checked;
        const wasAtBottom = isScrolledToBottom(logsEl);
        
        fetch(`/api/jobs/${jobId}/logs`)
            .then(response => response.json())
            .then(data => {
                // Update command
                const commandEl = document.getElementById(`command-${jobId}`);
                commandEl.textContent = data.ffmpeg_command || 'Command not available';
                
                // Update logs
                logsEl.textContent = data.ffmpeg_logs.join('\n') || 'No logs available';
                
                // Auto-scroll to bottom if auto-refresh is enabled or user was already at bottom
                if (shouldAutoScroll || wasAtBottom) {
                    setTimeout(() => scrollToBottom(logsEl), 10);
                }
            })
            .catch(error => {
                console.error('Error fetching logs:', error);
            });
    }
    
    // Check if element is scrolled to bottom
    function isScrolledToBottom(el) {
        // Allow a small buffer (5px) to account for rounding errors
        return el.scrollHeight - el.clientHeight - el.scrollTop <= 5;
    }
    
    // Scroll element to bottom
    function scrollToBottom(el) {
        el.scrollTop = el.scrollHeight;
    }
    
    // Auto-refresh logs for processing jobs
    const refreshIntervals = {};
    
    document.querySelectorAll('.auto-refresh-logs').forEach(checkbox => {
        const jobId = checkbox.getAttribute('data-job-id');
        
        checkbox.addEventListener('change', function() {
            if (this.checked) {
                // Start auto-refresh
                refreshIntervals[jobId] = setInterval(() => {
                    if (openLogStates.has(jobId)) {
                        loadJobLogs(jobId);
                    }
                }, 3000);
                
                // Immediately scroll to bottom when auto-refresh is enabled
                const logsEl = document.getElementById(`logs-content-${jobId}`);
                scrollToBottom(logsEl);
            } else {
                // Stop auto-refresh
                clearInterval(refreshIntervals[jobId]);
                delete refreshIntervals[jobId];
            }
        });
        
        // Initialize auto-refresh if checked
        if (checkbox.checked) {
            refreshIntervals[jobId] = setInterval(() => {
                if (openLogStates.has(jobId)) {
                    loadJobLogs(jobId);
                }
            }, 3000);
        }
    });
    
    // Start the auto-refresh mechanism on page load
    initializeAutoRefresh();
</script>
{% endblock %}