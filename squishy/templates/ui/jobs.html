{% extends 'base.html' %}

{% block title %}Transcoding Jobs - Squishy{% endblock %}

{% block content %}
<div class="jobs-list">
    <h1>Transcoding Jobs</h1>

    {# Macro for job row to avoid code duplication #}
    {% macro render_job_row(item, queue_index=0) %}
    <tr data-job-id="{{ item.job.id }}">
        <td>{{ item.media_title }}</td>
        <td>{{ item.file_size }}</td>
        <td>{{ item.job.profile_name }}</td>
        <td class="status-{{ item.job.status }} status" data-job-id="{{ item.job.id }}">
            {{ item.job.status }}
            {% if item.job.status == "pending" and queue_index > 0 %}
            <span class="queue-position">(Queue position: {{ queue_index }})</span>
            {% endif %}
        </td>
        <td>
            {% if item.job.status == "processing" %}
            <div class="progress-container">
                <div class="progress-bar-row">
                    <progress value="{{ item.job.progress }}" max="1.0"></progress>
                    <span class="progress-text">{{ (item.job.progress * 100)|int }}%</span>
                </div>
                {% if item.job.current_time and item.job.duration %}
                <span class="progress-time">{{ item.job.current_time|int }}s / {{ item.job.duration|int }}s</span>
                {% endif %}
            </div>
            {% elif item.job.status == "completed" %}
            <span class="status-complete">Complete</span>
            {% elif item.job.status == "failed" %}
            <span class="status-failed">Failed</span>
            {% elif item.job.status == "cancelled" %}
            <span class="status-cancelled">Cancelled</span>
            {% else %}
            <span class="status-pending">Pending</span>
            {% endif %}
        </td>
        <td>
            <div class="action-buttons-container">
                {% if item.job.status == "completed" %}
                    {% if item.job.output_path %}
                    <a href="{{ url_for('ui.download_file', filename=item.job.output_path.split('/')[-1]) }}"
                       class="circle-button download-circle-button" title="Download">
                        <img src="/static/img/download.svg" alt="Download" width="16" height="16">
                    </a>
                    {% endif %}

                    <button class="circle-button logs-circle-button" data-job-id="{{ item.job.id }}" title="Log">
                        <img src="/static/img/log.svg" alt="Log" width="16" height="16">
                    </button>
                {% elif item.job.status == "processing" or item.job.status == "pending" %}
                    <form action="{{ url_for('ui.cancel_job', job_id=item.job.id) }}" method="post" class="cancel-form">
                        <button type="submit" class="circle-button cancel-button" title="Cancel">
                            <img src="/static/img/cancel.svg" alt="Cancel" width="16" height="16">
                        </button>
                    </form>

                    {% if item.job.status == "processing" %}
                    <button class="circle-button logs-circle-button" data-job-id="{{ item.job.id }}" title="Show Log">
                        <img src="/static/img/log.svg" alt="Log" width="16" height="16">
                    </button>
                    {% endif %}
                {% elif item.job.status in ["failed", "cancelled"] %}
                    <button class="circle-button logs-circle-button" data-job-id="{{ item.job.id }}" title="Show Log">
                        <img src="/static/img/log.svg" alt="Log" width="16" height="16">
                    </button>
                {% endif %}
            </div>
        </td>
    </tr>

    {% if item.job.status in ["processing", "failed", "completed", "cancelled"] %}
    <tr class="logs-row" id="logs-{{ item.job.id }}" style="display: none;">
        <td colspan="6">
            <div class="logs-container">
                <h3>FFmpeg Command:</h3>
                <pre class="ffmpeg-command" id="command-{{ item.job.id }}">Loading...</pre>
                <h3>FFmpeg Log:</h3>
                <pre class="ffmpeg-logs" id="logs-content-{{ item.job.id }}">Loading...</pre>

                {% if item.job.status == "processing" %}
                <div class="auto-refresh-toggle">
                    <label>
                        <input type="checkbox" class="auto-refresh-logs" data-job-id="{{ item.job.id }}" checked>
                        Auto-refresh logs
                    </label>
                </div>
                {% endif %}
            </div>
        </td>
    </tr>
    {% endif %}
    {% endmacro %}

    {# Active Jobs Section #}
    <h2>Active Jobs</h2>
    {% if active_jobs %}
    <table>
        <thead>
            <tr>
                <th>Media</th>
                <th>Size</th>
                <th>Profile</th>
                <th>Status</th>
                <th>Progress</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            {% for item in active_jobs %}
                {{ render_job_row(item, loop.index0) }}
            {% endfor %}
        </tbody>
    </table>
    {% else %}
    <div class="empty-state">
        <p>No active jobs.</p>
    </div>
    {% endif %}

    {# Completed Jobs Section #}
    <h2>Completed Jobs</h2>
    {% if completed_jobs %}
    <table>
        <thead>
            <tr>
                <th>Media</th>
                <th>Size</th>
                <th>Profile</th>
                <th>Status</th>
                <th>Progress</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            {% for item in completed_jobs %}
                {{ render_job_row(item) }}
            {% endfor %}
        </tbody>
    </table>
    {% else %}
    <div class="empty-state">
        <p>No completed jobs.</p>
    </div>
    {% endif %}

    {# Failed Jobs Section #}
    <h2>Failed/Cancelled Jobs</h2>
    {% if failed_jobs %}
    <table>
        <thead>
            <tr>
                <th>Media</th>
                <th>Size</th>
                <th>Profile</th>
                <th>Status</th>
                <th>Progress</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            {% for item in failed_jobs %}
                {{ render_job_row(item) }}
            {% endfor %}
        </tbody>
    </table>
    {% else %}
    <div class="empty-state">
        <p>No failed or cancelled jobs.</p>
    </div>
    {% endif %}
    
    {# Display a message if no jobs at all #}
    {% if not active_jobs and not completed_jobs and not failed_jobs %}
    <div class="empty-state">
        <p>No transcoding jobs found.</p>
    </div>
    {% endif %}
</div>
{% endblock %}

{% block scripts %}
<script>
    // Use WebSockets for real-time updates
    let pageReloadTimer = null;
    const openLogStates = new Set();
    const STORAGE_KEY = 'squishyOpenLogs';

    // Initialize the page
    function initializePage() {
        if (pageReloadTimer) {
            clearTimeout(pageReloadTimer);
        }

        // Load saved open log states from localStorage
        try {
            const savedOpenLogs = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            savedOpenLogs.forEach(jobId => openLogStates.add(jobId));

            // Restore open logs from localStorage
            openLogStates.forEach(jobId => {
                const logsRow = document.getElementById(`logs-${jobId}`);
                const toggleButton = document.querySelector(`.logs-circle-button[data-job-id="${jobId}"]`);

                if (logsRow && toggleButton) {
                    logsRow.style.display = 'table-row';
                    toggleButton.title = 'Hide Log';

                    // Load the logs content
                    loadJobLogs(jobId);

                    // Scroll to bottom after a delay to ensure content is loaded
                    setTimeout(() => {
                        const logsEl = document.getElementById(`logs-content-${jobId}`);
                        if (logsEl) scrollToBottom(logsEl);
                    }, 300);
                }
            });
        } catch (e) {
            console.error('Error loading saved log states:', e);
        }

        // Set up WebSocket event listener for job updates
        document.addEventListener('squishy:job_update', function(event) {
            const jobData = event.detail;
            if (jobData && jobData.id) {
                updateJobElement(jobData);
            }
        });

        // Do an initial fetch of all jobs to ensure we have the latest data
        fetch('/api/jobs')
            .then(response => response.json())
            .then(data => {
                // Get a list of all active job IDs
                const activeJobIds = data.jobs.map(job => job.id);

                // Remove any open log states for jobs that no longer exist
                [...openLogStates].forEach(jobId => {
                    if (!activeJobIds.includes(jobId)) {
                        openLogStates.delete(jobId);
                        saveOpenLogStates();
                    }
                });

                // Update job data for each job
                data.jobs.forEach(job => {
                    updateJobElement(job);
                });
            })
            .catch(error => {
                console.error('Error fetching initial job data:', error);
            });

        // Set up our own page reload every 60 seconds as a fallback
        // This is less important now with WebSockets but still good for reliability
        pageReloadTimer = setTimeout(function() {
            saveOpenLogStates();
            location.reload();
        }, 60000); // Increased from 30s to 60s since we're using WebSockets
    }

    // Save open log states to localStorage
    function saveOpenLogStates() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify([...openLogStates]));
        } catch (e) {
            console.error('Error saving log states:', e);
        }
    }

    // Update a specific job's UI elements
    function updateJobElement(job) {
        // Find the status element for this job - it might be in any of the three tables
        const statusEl = document.querySelector(`tr td.status[data-job-id="${job.id}"]`);
        if (!statusEl) return;
        
        // Check if the job status has changed
        const currentStatus = statusEl.className.split(' ').find(cls => cls.startsWith('status-')).replace('status-', '');
        if (currentStatus !== job.status) {
            // Status has changed - we need to reload the page to move the job to the correct table
            saveOpenLogStates();
            location.reload();
            return;
        }

        // Update the progress if it's a processing job
        const progressContainer = document.querySelector(`tr[data-job-id="${job.id}"] .progress-container`);
        if (progressContainer && job.status === 'processing') {
            const progressBar = progressContainer.querySelector('progress');
            const progressText = progressContainer.querySelector('.progress-text');
            const progressTime = progressContainer.querySelector('.progress-time');

            if (progressBar) progressBar.value = job.progress;
            if (progressText) progressText.textContent = `${Math.round(job.progress * 100)}%`;

            // If we have timing data, update it
            if (progressTime && job.current_time && job.duration) {
                progressTime.textContent = `${Math.round(job.current_time)}s / ${Math.round(job.duration)}s`;
            }
        }

        // If this job has logs open, refresh them
        if (openLogStates.has(job.id)) {
            loadJobLogs(job.id);
        }
    }

    // Toggle log visibility
    document.querySelectorAll('.logs-circle-button').forEach(button => {
        button.addEventListener('click', function() {
            const jobId = this.getAttribute('data-job-id');
            const logsRow = document.getElementById(`logs-${jobId}`);

            // Toggle visibility
            if (logsRow.style.display === 'none') {
                logsRow.style.display = 'table-row';
                this.title = 'Hide Log';

                // Load logs and scroll to bottom on initial load
                loadJobLogs(jobId);

                // After logs are loaded, ensure we scroll to bottom (for the initial view)
                setTimeout(() => {
                    const logsEl = document.getElementById(`logs-content-${jobId}`);
                    scrollToBottom(logsEl);
                }, 300);

                openLogStates.add(jobId);
                saveOpenLogStates(); // Save the state change
            } else {
                logsRow.style.display = 'none';
                this.title = 'Show Log';
                openLogStates.delete(jobId);
                saveOpenLogStates(); // Save the state change
            }
        });
    });

    // Load job logs
    function loadJobLogs(jobId) {
        const logsEl = document.getElementById(`logs-content-${jobId}`);
        const shouldAutoScroll = document.querySelector(`.auto-refresh-logs[data-job-id="${jobId}"]`)?.checked;
        const wasAtBottom = isScrolledToBottom(logsEl);

        fetch(`/api/jobs/${jobId}/logs`)
            .then(response => response.json())
            .then(data => {
                // Update command
                const commandEl = document.getElementById(`command-${jobId}`);
                commandEl.textContent = data.ffmpeg_command || 'Command not available';

                // Update logs
                logsEl.textContent = data.ffmpeg_logs.join('\n') || 'No logs available';

                // Auto-scroll to bottom if auto-refresh is enabled or user was already at bottom
                if (shouldAutoScroll || wasAtBottom) {
                    setTimeout(() => scrollToBottom(logsEl), 10);
                }
            })
            .catch(error => {
                console.error('Error fetching logs:', error);
            });
    }

    // Check if element is scrolled to bottom
    function isScrolledToBottom(el) {
        // Allow a small buffer (5px) to account for rounding errors
        return el.scrollHeight - el.clientHeight - el.scrollTop <= 5;
    }

    // Scroll element to bottom
    function scrollToBottom(el) {
        el.scrollTop = el.scrollHeight;
    }

    // Auto-refresh logs for processing jobs
    const refreshIntervals = {};

    document.querySelectorAll('.auto-refresh-logs').forEach(checkbox => {
        const jobId = checkbox.getAttribute('data-job-id');

        checkbox.addEventListener('change', function() {
            if (this.checked) {
                // Start auto-refresh
                refreshIntervals[jobId] = setInterval(() => {
                    if (openLogStates.has(jobId)) {
                        loadJobLogs(jobId);
                    }
                }, 3000);

                // Immediately scroll to bottom when auto-refresh is enabled
                const logsEl = document.getElementById(`logs-content-${jobId}`);
                scrollToBottom(logsEl);
            } else {
                // Stop auto-refresh
                clearInterval(refreshIntervals[jobId]);
                delete refreshIntervals[jobId];
            }
        });

        // Initialize auto-refresh if checked
        if (checkbox.checked) {
            refreshIntervals[jobId] = setInterval(() => {
                if (openLogStates.has(jobId)) {
                    loadJobLogs(jobId);
                }
            }, 3000);
        }
    });

    // Start the page initialization
    document.addEventListener('DOMContentLoaded', initializePage);
</script>
{% endblock %}
